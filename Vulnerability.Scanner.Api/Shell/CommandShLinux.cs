using System;
using System.Diagnostics;
using System.IO;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;

namespace Vulnerability.Scanner.Api.Shell
{
    public class CommandShLinux : ICommandLine
    {
        public CommandShLinux(ILogger<CommandShLinux> logger, IOptions<GeneralOptions> options)
        {
            _logger = logger;
            _options = options;
        }

        private readonly ILogger<CommandShLinux> _logger;
        private readonly IOptions<GeneralOptions> _options;

        public string Run(string command)
        {
            if (command == null)
                throw new ArgumentNullException(nameof(command));

            // Faced this issue: https://stackoverflow.com/questions/139593/processstartinfo-hanging-on-waitforexit-why ???

            // Important to notice: this is workaround for random terminal hang...
            // Likely terminal outputs over 7mb of data -> causes buffers to get full -> stuck.
            var tempFileLocation = GetTempFilePath();

            _logger.LogDebug($"Running command: /bin/sh -c \"{command} > {tempFileLocation}\"");

            var psi = new ProcessStartInfo
            {
                FileName = "/bin/sh",
                Arguments = $"-c \"{command.Replace("\"", "\\\"")} > {tempFileLocation}\"",
                UseShellExecute = false,
                RedirectStandardOutput = true,
                RedirectStandardError = true
            };

            var proc = new Process
            {
                StartInfo = psi
            };

            proc.Start();
            proc.WaitForExit(_options.Value.ShellTimeoutMs);

            var output = File.Exists(tempFileLocation) ? File.ReadAllText(tempFileLocation) : "no output";

            if (!proc.HasExited)
            {
                throw new InvalidOperationException($"Command '{command}' failed to exit during timeout '{_options.Value.ShellTimeoutMs}', likely command hangs. stdOut: {output}");
            }

            var error = proc.StandardError.ReadToEnd();

            if (!string.IsNullOrEmpty(error))
                throw new InvalidOperationException($"Failed to run commandline command, error: '{error}'. stdOut: {output}");

            File.Delete(tempFileLocation);

            return output;
        }

        private static string GetTempFilePath ()
        {
            var path = Path.GetTempPath ();
            var fileName = Guid.NewGuid ().ToString () + ".out";
            return Path.Combine (path, fileName);
        }
    }
}
