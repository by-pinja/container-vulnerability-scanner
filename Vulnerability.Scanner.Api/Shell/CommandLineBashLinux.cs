using System;
using System.Diagnostics;
using System.IO;
using Microsoft.Extensions.Options;

namespace Vulnerability.Scanner.Api.Shell
{
    public class CommandLineBashLinux : ICommandLine
    {
        private const int _timeoutSec = 60;

        public string Run(string command)
        {
            if (command == null)
                throw new ArgumentNullException(nameof(command));

            // Faced this issue: https://stackoverflow.com/questions/139593/processstartinfo-hanging-on-waitforexit-why ???

            // Important to notice: this is workaround for random terminal hang...
            // Likely terminal outputs over 7mb of data -> causes buffers to get full -> stuck.
            var tempFileLocation = GetTempFilePath();

            var psi = new ProcessStartInfo
            {
                FileName = "/bin/bash",
                Arguments = $"-c \"{command.Replace("\"", "\\\"")} > {tempFileLocation}\"",
                UseShellExecute = false,
                RedirectStandardOutput = true,
                RedirectStandardError = true
            };

            var proc = new Process
            {
                StartInfo = psi
            };

            proc.Start();
            proc.WaitForExit(_timeoutSec * 1000);

            var output = File.Exists(tempFileLocation) ? File.ReadAllText(tempFileLocation) : "no output";

            if (!proc.HasExited)
            {
                throw new InvalidOperationException($"Command '{command}' failed to exit during timeout '{_timeoutSec}', likely command hangs. stdOut: {output}");
            }

            var error = proc.StandardError.ReadToEnd();

            if (!string.IsNullOrEmpty(error))
                throw new InvalidOperationException($"Failed to run commandline command, error: '{error}'. stdOut: {output}");

            File.Delete(tempFileLocation);

            return output;
        }

        private static string GetTempFilePath ()
        {
            var path = Path.GetTempPath ();
            var fileName = Guid.NewGuid ().ToString () + ".out";
            return Path.Combine (path, fileName);
        }
    }
}
