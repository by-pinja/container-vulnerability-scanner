using System;
using System.Diagnostics;
using System.IO;
using Microsoft.Extensions.Options;

namespace Vulnerability.Scanner.Api.Shell
{
    public class CommandLineWindows : ICommandLine
    {
        public CommandLineWindows(IOptions<GeneralOptions> options)
        {
            _options = options;
        }

        private readonly IOptions<GeneralOptions> _options;

        public string Run(string command)
        {
            if (command == null)
                throw new ArgumentNullException(nameof(command));

            // Faced this issue: https://stackoverflow.com/questions/139593/processstartinfo-hanging-on-waitforexit-why ???

            // Important to notice: this is workaround for random terminal hang...
            // Likely terminal outputs over 7mb of data -> causes buffers to get full -> stuck.
            var tempFileLocation = GetTempFilePath();

            var psi = new ProcessStartInfo
            {
                FileName = "cmd.exe",
                Arguments = $"/C {command} > {tempFileLocation}",
                UseShellExecute = false,
                RedirectStandardOutput = true,
                RedirectStandardError = true
            };

            var proc = new Process
            {
                StartInfo = psi
            };

            proc.Start();
            proc.WaitForExit(_options.Value.ShellTimeoutMs);

            var output = File.Exists(tempFileLocation) ? File.ReadAllText(tempFileLocation) : "no output";

            if (!proc.HasExited)
            {
                throw new InvalidOperationException($"Command '{command}' failed to exit during timeout '{_options.Value.ShellTimeoutMs}', likely command hangs. Current output: {output}");
            }

            var error = proc.StandardError.ReadToEnd();

            if (!string.IsNullOrEmpty(error))
                throw new InvalidOperationException($"Failed to run commandline command, error: '{error}'");

            File.Delete(tempFileLocation);

            return output;
        }

        private static string GetTempFilePath()
        {
            var path = Path.GetTempPath();
            var fileName = Guid.NewGuid().ToString() + ".out";
            return Path.Combine(path, fileName);
        }
    }
}
