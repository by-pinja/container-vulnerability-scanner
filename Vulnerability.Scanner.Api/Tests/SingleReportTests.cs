using System;
using System.Linq;
using System.Net;
using System.Threading;
using System.Threading.Tasks;
using FluentAssertions;
using Microsoft.Extensions.DependencyInjection;
using Newtonsoft.Json.Linq;
using NSubstitute;
using NUnit.Framework;
using Protacon.NetCore.WebApi.TestUtil;
using Protacon.NetCore.WebApi.TestUtil.Extensions;
using Vulnerability.Scanner.Api.Clair;
using Vulnerability.Scanner.Api.Controllers.Models;
using Vulnerability.Scanner.Api.Data;
using Vulnerability.Scanner.Api.Shell;
using Vulnerability.Scanner.Api.Tests;

namespace Vulnerability.Scanner.Api.Tests
{
    [TestFixture]
    public class SingleReportTests
    {
        [Test]
        public async Task WhenImageIsSent_ThenResultsShouldBeSoonAvailable()
        {
            var host = SharedSetupFixture.Host;

            var result = await host
                .Post("/v1/scan/", new VulnerabilityScanRequest
                {
                    Image = "node:latest"
                })
                .ExpectStatusCode(HttpStatusCode.OK)
                .WithContentOf<VulnerabilityScanResponse>()
                .Select();

            await host.Get(result.ResultsUri)
                .WaitForStatusCode(HttpStatusCode.OK, timeout: TimeSpan.FromSeconds(10))
                .WithContentOf<VulnerabilityModel[]>()
                .Passing(x => x.Should().HaveCount(654));

            await host.Get(result.HtmlResultsUri)
                .WaitForStatusCode(HttpStatusCode.OK, timeout: TimeSpan.FromSeconds(10))
                .WithContentOf<string>()
                .Passing(x => x.Should().Contain("CVE-2018-1000001"));
        }

        [Test]
        public async Task WhenImageIsNotReady_ReturnProcessingPage()
        {
            var host = SharedSetupFixture.Host;

            host.Host.Services
                .GetService<ICommandLine>()
                .When(x => x.Run(Arg.Is<string>(a => a.Contains("something:something"))))
                .Do(async _ => await Task.Delay(60*1000));

            var result = await host
                .Post("/v1/scan/", new VulnerabilityScanRequest
                {
                    Image = "something:something"
                })
                .ExpectStatusCode(HttpStatusCode.OK)
                .WithContentOf<VulnerabilityScanResponse>()
                .Select();

            host.Invoking(x =>
                x.Get(result.ResultsUri)
                    .WaitForStatusCode(HttpStatusCode.OK, timeout: TimeSpan.FromSeconds(10)))
                .Should()
                .Throw<ExpectedStatusCodeException>();

            await host.Get(result.ResultsUri)
                .ExpectStatusCode(HttpStatusCode.NotFound)
                .WithContentOf<JObject>()
                .Passing(x => x["status"].Value<string>().Should().Be("Processing"));

            await host.Get(result.HtmlResultsUri)
                .ExpectStatusCode(HttpStatusCode.NotFound)
                .WithContentOf<string>()
                .Passing(x => x.Should().Contain("Processing"));
        }

        [Test]
        public async Task WhenGoogleImageIsSent_ThenUseGoogleAuthenticationInstead()
        {
            var host = SharedSetupFixture.Host;

            const string image = "eu.gcr.io/someproject/someimage:1.2.3";

            host.Host.Services.GetRequiredService<ICommandLine>().Run(Arg.Is<string>(x => x.Contains(image))).Returns("{ \"Vulnerabilities\": {}}");
            host.Host.Services.GetRequiredService<IGoogleCloud>().GetOAuth2Token().Returns("this_is_token");

            var result = await host
                .Post("/v1/scan/", new VulnerabilityScanRequest
                {
                    Image = image
                })
                .ExpectStatusCode(HttpStatusCode.OK)
                .WithContentOf<VulnerabilityScanResponse>()
                .Select();

            await host.Get(result.ResultsUri)
                .WaitForStatusCode(HttpStatusCode.OK, timeout: TimeSpan.FromSeconds(10));

            await host.Host.Services.GetRequiredService<IGoogleCloud>().Received(1).GetOAuth2Token();

            host.Host.Services.GetRequiredService<ICommandLine>()
                .Received(1).Run(Arg.Is<string>(x => x.Contains("DOCKER_PASSWORD=this_is_token") && x.Contains("DOCKER_USER=oauth2accesstoken")));
        }

        [Test]
        public async Task WhenInvalidReportIdIsFetched_ThenReturnNotFound()
        {
            var host = SharedSetupFixture.Host;

            await host.Get($"/v1/reports/{Guid.NewGuid()}")
                .ExpectStatusCode(HttpStatusCode.NotFound);

            await host.Get($"/v1/reports/{Guid.NewGuid()}/html")
                .ExpectStatusCode(HttpStatusCode.NotFound);
        }
    }
}